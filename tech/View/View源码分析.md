# View源码分析

总结：

- **打开一个Activity，当它的onCreate() ---> onStart() ---> onResume()生命周期都走完后，才将它的DecoView与新建的一个ViewRootImpl对象绑定在一起。同时，开始安排一次遍历View任务，也就是绘制View数的操作等待执行，然后将DecoView的parent设置成ViewRootImpl对象。** 这也就是为什么在onCreate() ---> onStart() ---> onResume()里获取不到View宽高的原因，因为在这个时候ViewRootImpl甚至都还没创建，更不用说是否已经执行过测量操作了。还可以得到一点信息是，一个Activity界面的绘制，其实是在onResume()之后才开始的。

1. **界面上任何一个View的刷新请求最终都会走到ViewRootImpl中的scheduleTraversals()方法里来安排一次遍历绘制View树的任务；**
2. **scheduleTraversals()会先过滤掉同一帧内的重复调用，在同一帧内只需要安排一次遍历绘制View树的任务即可。这个任务会在下一个屏幕刷新信号到来时调用performTraversals()遍历view树，遍历过程中会将所有需要刷新的View进行重绘；**
3. **接着scheduleTraversals()会往主线程的消息队列中发送一个同步屏障，拦截这个时刻之后所有的同步消息的执行，但不会拦截异步消息，以此来尽可能的保证当接收到屏幕刷新信号时可以尽可能第一时间处理遍历绘制View树的工作；**
4. **发送完同步屏障后，scheduleTraversals()才会开始安排一个遍历绘制View树的操作，做法是把performTraversals()封装到Runnable里面，然后调用Choreographer的postCallback()方法；**
5. **postCallback()方法会先将这个Runnable任务以当前时间戳放进一个待执行的队列里，然后判断，如果当前是在主线程就会直接调用一个native层方法；如果不是在主线程，会发送一个最高优先级的message到主线程，让主线程第一时间调用这个native层的方法；**
6. **native层的这个方法是用来向底层注册监听下一个屏幕刷新信号。当下一个屏幕刷新信号发出时，底层就会回调Choreographer的onVsync()方法来通知上层APP；**
7. **onVsync()方法被回调时，会往主线程的消息队列中发送一个执行doFrame()方法的消息，这个消息是异步消息，所以不会被同步屏障拦截住；**
8. **doFrame()方法会去取出之前放进待执行队列里的任务来执行，取出来的这个任务实际上就是ViewRootImpl的doTraversal()操作；**
9. **上述第四步到第八步涉及到的消息都手动设置成了异步消息，所以不会受到同步屏障的拦截；**
10. **doTraversal()方法会先移除主线程的同步屏障，然后调用performTraversals()开始根据当前状态判断是否需要执行performMeasure()测量、performLayout()布局、performDraw()绘制流程，在这几个流程中都会去遍历View树来刷新需要更新的View；**



## Q&A

**Q1：Android 每隔 16.6 ms 刷新一次屏幕到底指的是什么意思？是指每隔 16.6ms 调用 onDraw() 绘制一次么？**  
 **Q2：如果界面一直保持没变的话，那么还会每隔 16.6ms 刷新一次屏幕么？**  
 答：我们常说的 Android 每隔 16.6 ms 刷新一次屏幕其实是指底层会以这个固定频率来切换每一帧的画面，而这个每一帧的画面数据就是我们 app 在接收到屏幕刷新信号之后去执行遍历绘制 View 树工作所计算出来的屏幕数据。而 app 并不是每隔 16.6ms 的屏幕刷新信号都可以接收到，只有当 app 向底层注册监听下一个屏幕刷新信号之后，才能接收到下一个屏幕刷新信号到来的通知。而只有当某个 View 发起了刷新请求时，app 才会去向底层注册监听下一个屏幕刷新信号。

也就是说，只有当界面有刷新的需要时，我们 app 才会在下一个屏幕刷新信号来时，遍历绘制 View 树来重新计算屏幕数据。如果界面没有刷新的需要，一直保持不变时，我们 app 就不会去接收每隔 16.6ms 的屏幕刷新信号事件了，但底层仍然会以这个固定频率来切换每一帧的画面，只是后面这些帧的画面都是相同的而已。

**Q3：界面的显示其实就是一个 Activity 的 View 树里所有的 View 都进行测量、布局、绘制操作之后的结果呈现，那么如果这部分工作都完成后，屏幕会马上就刷新么？**  
 答：我们 app 只负责计算屏幕数据而已，接收到屏幕刷新信号就去计算，计算完毕就计算完毕了。至于屏幕的刷新，这些是由底层以固定的频率来切换屏幕每一帧的画面。所以即使屏幕数据都计算完毕，屏幕会不会马上刷新就取决于底层是否到了要切换下一帧画面的时机了。

**Q4：网上都说避免丢帧的方法之一是保证每次绘制界面的操作要在 16.6ms 内完成，但如果这个 16.6ms 是一个固定的频率的话，请求绘制的操作在代码里被调用的时机是不确定的啊，那么如果某次用户点击屏幕导致的界面刷新操作是在某一个 16.6ms 帧快结束的时候，那么即使这次绘制操作小于 16.6 ms，按道理不也会造成丢帧么？这又该如何理解？**  
 答：之所以提了这个问题，是因为之前是以为如果某个 View 发起了刷新请求，比如调用了 `invalidte()`，那么它的重绘工作就马上开始执行了，所以以前在看网上那些介绍屏幕刷新机制的博客时，经常看见下面这张图：

![img](https:////upload-images.jianshu.io/upload_images/1924341-d8ebbbd67051dd6b.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)

image.png



那个时候就是不大理解，为什么每一次 CPU 计算的工作都刚刚好是在每一个信号到来的那个瞬间开始的呢？毕竟代码里发起刷新屏幕的操作是动态的，不可能每次都刚刚好那么巧。

梳理完屏幕刷新机制后就清楚了，代码里调用了某个 View 发起的刷新请求，这个重绘工作并不会马上就开始，而是需要等到下一个屏幕刷新信号来的时候才开始，所以现在回过头来看这些图就清楚多了。

**Q5：大伙都清楚，主线程耗时的操作会导致丢帧，但是耗时的操作为什么会导致丢帧？它是如何导致丢帧发生的？**  
 答：造成丢帧大体上有两类原因，一是遍历绘制 View 树计算屏幕数据的时间超过了 16.6ms；二是，主线程一直在处理其他耗时的消息，导致遍历绘制 View 树的工作迟迟不能开始，从而超过了 16.6 ms 底层切换下一帧画面的时机。

第一个原因就是我们写的布局有问题了，需要进行优化了。而第二个原因则是我们常说的避免在主线程中做耗时的任务。

针对第二个原因，系统已经引入了同步屏障消息的机制，尽可能的保证遍历绘制 View 树的工作能够及时进行，但仍没办法完全避免，所以我们还是得尽可能避免主线程耗时工作。

其实第二个原因，可以拿出来细讲的，比如有这种情况， message 不怎么耗时，但数量太多，这同样可能会造成丢帧。如果有使用一些图片框架的，它内部下载图片都是开线程去下载，但当下载完成后需要把图片加载到绑定的 view 上，这个工作就是发了一个 message 切到主线程来做，如果一个界面这种 view 特别多的话，队列里就会有非常多的 message，虽然每个都 message 并不怎么耗时，但经不起量多啊。后面有时间的话，看看要不要专门整理一篇文章来讲卡顿和丢帧的事。